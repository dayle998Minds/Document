# MySQL vs Maria DB
마이SQL은 글로벌 IT업체 오라클의 소유

마리아DB는 마이SQL 창시자인 마이클 몬티 위드니우스 주도 아래 개발됐다. 마이SQL과 동일한 코드에 기반하고 있고 사용방법이나 구조도 동일하다. 따라서 마이SQL과 완벽하게 호환된다.

스카이SQL은 지난해 마이클 몬티 위드니우스가 설립한 마리아SQL 기술지원 업체 몬티프로그램을 인수하며 마리아DB에 대한 지원을 한층 강화한 상황. 패트릭 샐너 CEO는 "마리아DB는 오픈SW DBMS의 표준으로 부상하고 있으며 스카이SQL은 마리아DB와 마리아DB재단을 지원하는 가장 핵심적인 업체"라고 설명했다.

마리아DB는 스토리지엔진을 제외하면 마이SQL 5.5버전과 동일한 기능을 제공하고, 바이너리호환성도 100%에 가깝다. 다만, 마리아DB는 오라클 소유인 이노DB를 대체하기 위해 여러 스토리지 엔진을 옵션으로 제공한다. 마리아DB는 마이ISAM, 블랙홀, CSV, 메모리, 아카이브 등 마이SQL에서 지원했던 주요 오픈소스 스토리지엔진 지원기능을 포함한다.

 
# 데이터베이스 엔진비교
---
## Maria DB의 데이터베이스 엔진(스토리지 엔진)
MariaDB는 원칙적으로 MySQL과 거의 동일한 데이터베이스 엔진을 제공한다.
Maria는 MyISAM에 비해 트랜잭션 기능과 비정상 종료 시 복구기능을 추가한 것으로 MyISAM의 약점이 크게 보완

### Aria - MyISAM 파생 엔진 대체용 (이전 명칭은 Maria)
아리아(Aria)는 MySQL과 MariaDB를 위한 새로운 스토리지 엔진이다. 
- MyISAM보다는 효율적이고 안정적으로 작동
- MariaDB의 경우 내부 임시테이블을 생성할때 Aria Storage Engine사용

### XtraDB - 오라클 InnoDB를 대체하기 위해 만든 InnoDB 파생 포크
- windows 미지원
- 트랜젝션 지원

### FederatedX - MySQL Federated 파생 엔진, 트랜잭션 제공
MySQL 관계형 데이터베이스 관리 시스템용 MySQL Federated 저장 엔진은 유저가 외부(또는 원격) 테이블을 로컬로 보여주는 테이블을 생성할 수 있게 해주는 저장 엔진이다. 이것은 MySQL 클라이언트 라이브러리 API를 데이터 통로로 이용하여, 원격의 데이터 소스를 동일하게 다른 저장 엔진으로 취급하여 로컬 데이터 자료를 MYD 파일(MyISAM), 메모리(클러스터, 힙) 또는 테이블스페이스(InnoDB)에 상관없이 취급한다. 그곳에 규정된 각 Federated 테이블은 하나의 .frm (데이터 소스 URL과 같은 정보를 포함한 데이터 정의 파일)이다. 실제 데이터는 로컬 또는 원격의 MySQL 인스턴스에 존재한다.

### OQGRAPH - 버전 5.2 이상에서 지원
### SphinxSE - 버전 5.2 이상에서 지원, Full-Text Searching이 필요할 때 사용할 수 있는 스토리지 엔진
### Cassandra - 
실제 Cassandra Cluster가 MariaDB서버 내부에 구현된것이 아니라 MariaDB가 원격 서버에 있는 카산드라 서버로 접속하여 필요한 데이터를 SQL문법으로 조회할수 있도록 해주는 스토로지엔진
10.0에서 포함. 기타 비 sql 저장 엔진을 끌어들이려는 시도
- MariaDB-10.0부터 NoSQL에 관련된 기능 추가

### TokuDB - Fractal Tree Indexes로 운영되는 DBMS
MariaDB에서 Load해서 사용,  장점은 다른 엔진보다 압축률이 높음
Fractal Tree는 "Big I/O"에 촛점을 맞춘 자료 구조로, 잦은 Disk I/O를 줄이고, 한번에 다량의 데이터를 하단 노드로 전달함에 따라 데이터가 많은 상황에서도 효과적으로 처리할수 있는 방안.
- 트랜젝션 지원

### Connect 
ConnectStorage Engine은 XML이나 Excel파일 그리고 Oracle이나 MSSQL과 같은 DBMS들의 테이블을 MariaDB에 직접 쿼리할수 있도록 연결 기능을 제공해주는 스토리지 엔진이다.

---
## MySQL의 데이터베이스 엔진
### MyISAM
- 상대적으로 높은 성능
- 읽기 위주의 요청에 유리
- 테이블 단위 락킹 
### InnoDB
이노DB(InnoDB)는 MySQL을 위한 데이터베이스 엔진이다

- 트랜젝션 지원
- 빈번한 쓰기, 수정, 삭제시 처리 능력
- 디스크, 전원 등의 장애 발생시 복구 성능
- 동시처리가 많은 환경에 적합
- Row 단위 락킹 

### Cluster(NDB)
트랜잭션을 지원하고 모든 데이터와 인덱스가 메모리에 존재하여 매우 빠른 데이터 로드 속도를 자랑하며 PK 사용시 최상의 속도를 나타낸다.

### Archive
MySQL 5.0부터 새롭게 도입된 엔진으로 자동적으로 데이터 압축을 지원하며 다른 엔진에 비해 80% 저장공간 절약 효과를 자랑한다. 그리고 가장 빠른 데이터 로드 속도 또한 자랑하지만, INSERT와 SELECT만이 가능하다.
### Federated
MySQL 5.0부터 새롭게 도입된 엔진으로 물리적 데이터베이스에 대한 논리적 데이터베이스를 생성하여 원격 데이터를 컨트롤 할 수 있다. 실행속도는 네트워크 요소에 따라 좌우되면 테이블 정의를 통한 SSL 보안 처리를 한다. 분산 데이터베이스 환경에 사용한다

## 적절한 스토리지엔진 선택

### Maria vs. InnoDB
주요한 스토리지 엔진인 MyISAM과 InnoDB를 비교하여 실무에서는 적절한 스토리지 엔진을 선택합니다. 기본 엔진으로 InnoDB를 선택하고, 추가처리만 하는 경우에는 MyISAM을 사용하는 식으로 구분해서 사용하기도 합니다. 물론 절대적인 기준은 없고 case-by-case로 선택하는 경우가 많습니다. 하지만 확실한 것은 1대의 서버에 두 가지를 혼용하지 않는 것이 좋습니다. 이둘은 각기 다른 동작, 메모리 사용법을 취하므로 혼용하는 환경에서는 효율적인 CPU, 메모리 사용이 어려워집니다.

 액세스 패턴 | 적합한 스토리지 엔진
 --------- | ---------
 추가 처리만 함 |  MyISAM 
 갱신빈도가 높음 |  InnoDB
 트랜잭션이 필요 |  InnoDB
 SELECT COUNT(*)를 사용 |  MyISAM

# DB 기본 용어 
### Data Definition Language - DDL : 데이터 정의 언어 
SCHEMA, DOMAIN, TABLE, VIEW, INDEX 를 다음 명령어로 정의, 변경, 삭제합니다.

- CREATE : 정의 
- ALTER: 수정
- DROP : 삭제
- TRUNCATE : DROP 후 CREATE

Oracle 11g 이전 버전과 MySQL은 DDL에 대해서 트랜잭션을 지원하지 않는다.
(Rollback 할 수 없고 Commit할 필요도 없다.)
### Data Manipulation Language - DML : 데이터 조작 언어
데이터를 조작 (조회, 추가, 변경, 삭제) 하기 위해 사용합니다.
- SELECT : 조회
- INSERT : 추가
- DELETE : 삭제
- UPDATE : 변경
기본적인 위의 명령어 외에 LOCK, EXPLAIN, CALL 등도 DML에 포함 됩니다.
### Data Control Language - DCL : 데이터 제어 언어
데이터의 보안, 무결성, 회복, 병행 수행제어 등을 정의하는데 사용합니다.
- COMMIT : 트랜잭션의 작업 결과를 반영 
- ROLLBACK : 트랜잭션의 작업을 취소 및 원래대로 복구
- GRANT : 사용자에게 권한 부여
- REVOKE : 사용자 권한 취소
### OLTP: On-Line Transaction Processing (데이터 갱신위주)
네트워크 상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위작업을 처리하는 방식\ 
ex) 은행 입출금
### OLAP: On-Line Analytic Processing (데이터 조회위주)
정보위주의 처리 분석을 의미\
의사결정에 활용할 수 있는  정보를 얻을 수 있게 해주는 기술\
ex) 판매추이, 구매성향파악, 재무회계분석 등

## 정적 쿼리 & 동적 쿼리
- 정적 쿼리 방식 : 변수가 바뀔 때마다 새로운 SQL 을 생성 하여 DB쿼리 수행
ex) insert into person values (null, '홍길동', '888888-1111111', '2002-02-02');
- 동적 쿼리 방식 : 변수가 바뀔 때마다 파싱을 하지 않고 변수 바인딩 과정을 통해 DB 쿼리 수행
ex) insert into person values (null, ?, ?, ?);\
쿼리문을 이런 식으로 해놓고 ? 부분을 변수 바인딩을 통해 입력받는 것을 동적 쿼리라고 합니다.

### STATIC SQL & DYNAMIC SQL 처리 방법 비교
- STATIC SQL
  CURSOR절에 Static SQL 생성 -> CURSOR OPEN -> CURSOR FETCH -> RECORD TYPE에 데이터 저장 -> CURSOR CLOSE
- DYNAMIC SQL
  SQL 구문 담을 변수 생성 -> 로직 처리로 SQL 구문 생성 -> Dynamic SQL을 REF CURSOR에 저장 -> REF CURSOR OPEN -> REF CURSOR FETCH -> RECORD TYPE에 데이터 저장 -> REF CURSOR CLOSE
STATIC SQL은 고정된 SQL형태로 만든 뒤에 이 SQL형태로 모든 조건들을 처리해야 하는 반면, DYNAMIC SQL은 여러 로지으로 조건에 해당되는 SQLdmf qustndp ekadktj aksems enldp 유ㅡㄴ를 콜하기 때문에 보다 풍부한 SQL를 작성.
DYNAMIC SQL를 잘사용하지 않는 이유는 개발 난이도도 높고, 개발시간되 현저히 늘어난다는 점, 로직으로 SQL을 만들어 나가기때문에 직관적이지 못함

## 오라클 제약조건(UK, CK, PK, FK)
### UNIQUE KEY(UK)
- 테이블내에서 해당 컬럼 값은 항상 유일해야 한다.
- PRIMARY KEY(PK)와 유사하나 NULL값을 중복 허용한다.
- 내부적으로 UNIQUE INDEX를 만들어 처리한다.
- 테이블 내에서 UK는 여러번 지정 가능하다.
### CHECK(CK)
- 해당 컬럼에 저장 가능한 데이터 값의 범위나 조건을 지정한다.
- 컬럼에 입력되는 데이터를 검사해서 조건에 맞는 데이터만 입력되도록 한다.
### PRIMARY KEY(PK)
- 해당 컬럼 값은 반드시 존재해야 하며, 유일해야 한다.
- 테이블에 대한 기본키를 생성한다.
- 기본키는 테이블 당 하나만 존재하며 반드시 하나의 컬럼으로만 구성되는 것은 아니다.
- NULL값이 입력될 수 없고, 이미 테이블에 존재하고 있는 데이터를 다시 입력할 수 없다.
- UNIQUE INDEX가 자동으로 만들어진다.
- NOT NULL과 UNIQUE 제약조건을 결합한 형태이다. 
### FOREIGN KEY(FK)
- 해당 컬럼 값은 참조되는 테이블의 컬럼 값 중의 하나와 일치하거나 NULL을 가진다.
- 두 테이블의 데이터 간 연결을 설정하고 강제 적용한다.
- 참조하고자 하는 컬럼이 PRIMARY KEY(PK) 또는 UNIQUE KEY가 잡혀있어야 사용가능하다.
- 부모 테이블을 삭제하기 위해서는 자식 테이블을 먼저 삭제해야한다.
## TRIGGER
데이터베이스 트리거(Database Trigger)는 테이블에 대한 이벤트에 반응해 자동으로 실행되는 작업을 의미한다. 트리거는 데이터 조작 언어(DML)의 데이터 상태의 관리를 자동화하는 데 사용된다. 트리거를 사용하여 데이터 작업 제한, 작업 기록, 변경 작업 감사 등을 할 수 있다.

트리거에는 크게 나누어 행 트리거와 문장 트리거의 두 종류가 있다.

- 행 트리거: 테이블 안의 영향을 받은 행 각각에 대해 실행된다. 변경 전 또는 변경 후의 행은 OLD, NEW라는 가상 줄 변수를 사용하여 읽을 수 있다.
- 문장 트리거:INSERT, UPDATE, DELETE 문에 대해 한번만 실행된다.
### 트리거 속성을 갖는다.

- BEFORE 또는 AFTER : 트리거가 실행되는 시기를 지정한다.
- INSTEAD OF : 트리거를 원래 문장 대신 수행한다.
- WHEN : 트리거를 시작하는 조건식을 지정한다.
일반적으로 트리거는 다음의 3 가지 경우에 시작된다. 트리거는 SELECT 문에 의한 데이터 검색에 영향을 미칠 수 없다.
- INSERT (새로운 행 삽입)
- UPDATE (기존 행의 변경) / UPDATE OF (기존 행의 특정 열 변경)
- DELETE (기존 행 삭제)
```
 CREATE TRIGGER salary_trigger
     BEFORE UPDATE ON employee_table
     REFERENCING NEW ROW AS n, OLD ROW AS o
     FOR EACH ROW
     IF n.salary <> o.salary THEN
        ...
     END IF;
```

## SQL Object의 종류 
- 테이블 : 행과 열의 조합으로 구성된 데이터의 기본 저장 단위.
- 시퀀스 : 자동으로 고유한 숫자값을 생성해주며 주로 기본 키 값을 생성하기 위해 사용.
- 인덱스 : 쿼리 속도를 향상.
- 뷰 : 하나 또는 그 이상의 테이블로부터 논리적으로 데이터를 추출한 부분집합으로 논리적이고 가상적인 테이블

### SEQUENCE
자동으로 Unique number를 생성\
공유가능한 Object\
일반적으로 Primary Key값 생성을 위해 사용
```
CREATE SEQUENCE 이름
    [INCREMENT BY n]
    [START WITH n]
    [{MAXVALUE n | NOMAXVALUE }]
    [{MINVALUE n | NOMINVALUE}]
    [{CYCLE | NOCYCLE}]
    [{CACHE | NOCACHE}]
```
사용법 :
NEXTVAL, CURRVAL 의사 컬럼의 사용\
NEXTVAL은 사용 가능한 다음 SEQUENCE값을 반환한다.\
NEXTVAL은 다른 사용자에 의해 참조되더라도 매번 고유한 값을 반환한다.\
CURRVAL은 현재 SEQUENCE 값을 포함한다.\
CURRVAL은 반드시 NEXTVAL사용 후에 참조되어야 한다.

### 인덱스
테이블의 데이터를 좀더 빠르게 검색하기 위해 사용하는 데이터베이스 Object이다.\
오라클서버가 최적화 방법에 따라 어떤 Index를 사용할 것인지, 혹은 Index를 사용하지 않을 것인지를 결정한다.\
B*트리의 검색방법으로 디스크 입출력(I/O) 횟수를 줄인다.\
오라클 서버가 Index를 자동적으로 사용하고 유지보수한다.\
Index는 논리적, 물리적으로 테이블과는 독립적이다.\
Index는 자동으로 생성되기도 하고 사용자가 필요에 의해 만들기도 한다.\
\
인덱스 생성을 위한 지침
- 인덱스를 만들 때
  - 조건절이나 조인조건에서 컬럼을 자주 이용할 때
  - 컬럼이 넓은 범위값을 가질 때
  - 많은 NULL값을 갖는 컬럼일 때
  - 테이블의 데이터가 많고 그 테이블에서 조회되는 행의 수가 전체의 10-15%정도 일때
- 인덱스를 만들지 않아야 할 때
  - 테이블이 작을 때
  - 컬럼이 조회의 조건으로 사용되는 경우가 별로 없을 때
  - 대부분의 조회가 행의 10-15% 이상을 검색한다고 예상될 때
  - 테이블이 자주 변경될때

### View
view란 테이블이나 다른 뷰를 기초로 한 논리적이고 가상의 테이블이다.\
view는 자체의 데이타는 없지만 테이블의 데이타를 보거나 변경할 수 있는 창과 같다.\
view는 실제적으로 질의문장을 가진다.
\
장점\
뷰는 데이타베이스의 선택적인 내용을 보여줄 수 있기 때문에 데이터베이스에 대한 액세스를 제한한다.\
복잡한 질의어를 통해 얻을 수 있는 결과를 간단한 질의어를 써서 구할 수 있게 한다. 예를 들면 조인 방법을 몰라도 조인을 한 것처럼 여러 테이블에 대한 데이타를 뷰를 통해 볼 수 있다.\
한 개의 뷰로 여러 테이블에 대한 테이타를 검색할 수 있다.\
\
생성
```
CREATE [OR REPLACE] [FORCE | NOFORCE ] VIEW 이름 [(alias[,alias]...)]
    AS subquery
    [WITH CHECK OPTION [CONSTRAINT 제약 조건]]
    [WITH READ ONLY]
```
뷰에 대한 DML문 사용 규칙\
간단한 뷰에서는 DML연산 수행 가능\
뷰가 다음 사항을 포함하는 경우 행을 삭제할 수 없음\
- 조인 조건
- 그룹 함수
- GROUP BY 절
- DISTINCT 명령

뷰가 다음 사항을 포함하는 경우 데이터를 수정할 수 없음
- 위의 조건
- 식으로 정의된 컬럼

뷰가 다음 사항을 포함하는 경우 데이터를 추가할 수 없음
- 위의 조건
- VIEW에 선택되지 않는 NOT NULL 컬럼

## Oracle 과 Mysql 차이
1. 공백치환 함수 ( NVL -> IFNULL )
Oracle : SELECT NVL('컬럼명', '') FROM DUAL;
MySql : SELECT IFNULL('컬럼명', '') FROM DUAL;

2. 현재 날짜시간
Oracle : SYSDATE
Mysql  : NOW() 

3. 날짜포멧 
Oracle : TO_CHAR(sysdate,'MMDDYYYYHH24MISS')
Mysql  : DATE_FORMAT(now(),'%Y%m%d%H%i%s')  -> 여기서 대문자Y는 4자리 년도, 소문자 y는 2자리 년도

4. 날짜 포멧 : 요일
Oracle : 요일이 1~7로 인식함  -> TO_CHAR(SYSDATE - 1, 'D') 
Mysql : 요일이 0~6으로 인식   -> DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 DAY), '%w')
* 참고로 자바스크립트가 0~6으로 인식하기에 Oracle 쿼리에서 -1을 해서 맞추는 경우가 많음

5. Like절 '%' 사용법
Oracle : Like '%'||'문자'||'%' 이런식으로 컬럼명 앞뒤로 '%'를 붙여주면 된다
Mysql : LIKE CONCAT('문자','%') 이런식으로 CONCAT 함수 사용

6. 형변환
Oracle : To_char, To_number 등
Mysql : CAST
SELECT TO_CHAR(1234) FROM DUAL 
-> SELECT CAST(1234 AS CHAR) FROM DUAL

7. 대소문자 구분함
Oracle : 구분없음
Mysql : 기본적으로 구분하나, 설정으로 변경 가능함

8. ROWNUM
Oracle : where 절에 rownum > 5 and rownum =< 10 
Mysql : where절 없이 limit 5,10

9. Sequence(시퀀스)는 둘 다 사용자함수를 만들어서 아래와 같이 사용
Oracle : 시퀀스명.nextval
Mysql : 시퀀스명.currval

10. 문자열 자르기
Oracle: SUBSTR(문자열, 1, 10)
Mysql: SUBSTRING(문자열, 1,10), LEFT(문자열, 3), RIGHT(문자열, 3)

11. 문자열 합치기 ( - 문자열을 연결한다고 가정)
Oracle: 문자열(또는 컬럼) ||' - '
Mysql: CONCAT(문자열(또는 컬럼), ' - ')

12. 예약어가 컬럼명일 때
Oracle: 컬럼명을 따옴표(")로 감싸기 (예: select "column" from tab)
Mysql: 컬럼명을 TAB 키 위에 있는 ` 키 ( Single quotation )로 감싸기

13. 저장프로시저 있는지 여부 파악해서 Create 하기
Oracle: CREATE OR REPLACE PROCEDURE 프로시저명
Mysql: DROP PROCEDURE IF EXISTS 프로시저명; 을 한 뒤에 CREATE PROCEDURE 프로시저명

### 더 빠른 SQL 쿼리를 위한 21가지 데이터베이스 튜닝 규칙
데이터베이스 튜닝은 기술인 동시에 과학이다. 다음은 사용 중인 데이터베이스를 더 빠르고 더욱 효과적으로 만들어주는 21가지 입증된 규칙이다.

1. 가능하면 커서(Cursor)를 피하라.
커서는 일련의 데이터에 순차적으로 액세스할 때 검색 및 현재 위치를 포함하는 데이터 요소를 말한다. 커서를 피하는 것은 아주 쉬운 결정이다. 커서는 속도 문제를 겪을 뿐 아니라, 다른 작업을 필요 이상 지연시킬 정도로 하나의 작업을 블록(Block)시킬 수도 있다. 이는 시스템의 동시성을 크게 저하시킨다.

2. 커서를 피할 수 없다면, 임시 테이블(temp table)을 사용하라
커서를 사용해야만 할 때가 있다. 그런 경우, 라이브 테이블(Live Table)보다는 임시 테이블에 대한 커서 작업을 수행하는 것이 더 낫다. 훨씬 더 작은 라이브 테이블에 대한 하나의 UPDATE 문이 있을 수 있다. 짧은 시간 동안에만 잠금(Lock)을 유지하게 되어 동시성을 크게 증진시켜 준다.

3. 임시 테이블을 현명하게 사용하라
다른 여러 가지 상황에서도 임시 테이블을 사용할 수 있다. 예를 들어, 어떤 테이블을 더 큰 테이블에 조인(Join) 시켜야만 한다면, 더 큰 테이블에서 필요한 일부 데이터만 임시 테이블로 끌어(Pull)와서 대신 그것과 조인시킴으로써 성능을 개선할 수 있다. 이는 필요한 처리 능력을 크게 줄여주며, 프로시저에 같은 테이블에 대해 유사한 조인을 해야만 하는 여러 개의 쿼리가 있는 경우 유용하다.

4. 데이터를 미리 준비하라
흔히 간과되는 예전의 기법이다. 커다란 테이블에 대해 비슷한 조인 작업을 할 보고서(Report)나 프로시저가 있다면, 미리 테이블을 조인시키고 테이블들을 하나의 테이블에 영속화(Persisted)시킴으로써 데이터를 사전 준비하라. 그렇게 하면, 사전 준비된 해당 테이블에 대한 보고서 작업을 실행할 수 있어서, 대규모 조인 작업을 피할 수 있다.
항상 이 기법을 사용할 수는 없지만, 대부분의 환경에는 늘 조인되는 인기 테이블이 있기 마련이다. 이런 테이블들을 사전에 준비하지 못할 이유가 전혀 없으며, 서버 자원을 절약하기 위한 훌륭한 방법이다.

5. 복합 뷰(Nested View)를 최소화하라
뷰는 엄청난 쿼리를 사용자들로부터 가리는데 훌륭하지만, 하나의 뷰 안에 또 다른 뷰와 내부에 있는 다른 뷰를 (계속해서) 중첩시키다 보면 심각한 성능 저하를 유발할 수 있다. 너무 많은 수의 복합 뷰는 모든 쿼리에 대해 엄청난 양의 데이터가 반환(Return) 되는 결과를 초래해서, 데이터베이스 성능을 말 그대로 기어 다니게 만들 수 있다. 혹은, 더 나가서, 쿼리 최적화기(Optimizer)가 포기해서 아무것도 반환되지 않을 수도 있다.
복합 뷰를 풀어내는 것으로 쿼리 응답 시간을 몇 분에서 몇 초로 줄일 수 있다.

6. UPDATE 문 대신 CASE 문을 사용하라
다음 시나리오를 살펴보자. 임시 테이블에 데이터를 삽입하고 있으며 다른 값이 존재할 경우 해당 데이터가 특정 값을 표시하도록 해야 한다. Customer 테이블에서 데이터를 끌어오고 있으며 주문 액수가 100,000달러 이상인 고객에 대해서 “우대”라는 라벨을 붙이고 싶어한다고 하자. 그래서, 100,000달러 이상의 주문 금액을 보유하고 있는 모든 고객에 대해서 CustomerRank 열에 “우대”라고 설정하기 위해 테이블에 데이터를 삽입하고 UPDATE 문을 실행한다.
논리적으로 보인다, 그렇지 않은가? 문제는 UPDATE 문이 로그된다는 것이다 즉, 테이블에 대한 모든 한 번의 쓰기 작업 당 두 번의 쓰기 작업이 일어난다는 의미이다. 물론, 이 문제를 피하는 방법은 SQL 쿼리 자체에서 인라인(Inline) CASE 문을 사용하는 것이다. 이는 모든 행에 대해 주문량 조건을 확인하고 테이블에 쓰기 전에 “우대” 라벨을 설정한다. 성능 증가는 깜짝 놀랄 정도이다.

7. 스칼라(Scalar) 대신 테이블 반환 함수(Table-Valued Functions)를 사용하라
전문가들이 사용하는 팁이 있다. 쿼리의 SELECT 목록에서 스칼라 함수를 사용할 경우, 그 대신에 쿼리에서 테이블 반환 함수를 사용하고 CROSS APPLY 문을 사용하면 성능을 개선할 수 있다. 이는 쿼리 시간을 절반으로 대폭 줄여줄 수 있다.

8. SQL 서버에서 분할(Partition)을 활용하라
SQL 서버 엔터프라이즈 사용자들은 성능을 가속화하기 위해 데이터 엔진의 자동 분할 기능을 활용할 수 있다. SQL 서버에서는 간단한 테이블조차도 하나의 분할로 생성되며, 사용자는 나중에 그것을 필요에 따라 여러 개의 분할로 쪼갤 수 있다. 테이블 간에 많은 양의 데이터를 옮겨야 할 경우, INSERT와 DELETE 문 대신에 SWITCH 명령을 사용할 수 있다. 테이블 간에 많은 양의 데이터를 삭제하고 삽입하는 대신, 단일 테이블에 대한 메타데이터만 변경하는 것이기 때문에, 실행하는데 몇 초 밖에 걸리지 않는다.

9. 배치 모드로 삭제(Delete)와 갱신(Update) 작업을 하라
거대한 테이블에서 많은 양의 데이터를 삭제하거나 업데이트하는 작업은 악몽일 수 있다. 문제는 이 두 가지 명령문 모두가 하나의 트랜잭션으로 실행되는 것이며, 프로세스를 중지시켜야 한다거나 작업 도중에 어떤 일이 일어진다면, 시스템은 전체 트랜잭션을 복원(Roll Back)시켜야만 한다. 이 작업은 진행 중인 다른 트랜잭션들을 블록 시킬 뿐 아니라, 많은 시간이 걸릴 수 있어서, 기본적으로 시스템 병목을 일으킨다.
해결책은 작은 배치 단위로 삭제나 업데이트 작업을 하는 것이다. 트랜잭션이 중지돼도, 소수의 행만 복원하면 되므로, 데이터베이스는 훨씬 더 빨리 온라인으로 돌아온다. 그리고 더 작은 배치작업들이 디스크에 커밋(Commit)하는 동안, 다른 작업들이 끼어들어서 어느 정도의 작업을 할 수 있어서 동시성이 크게 개선된다.

10. 서두르지 말고 천천히 하라
일부 개발자들은 이런 삭제와 업데이트 작업이 같은 날 완료되어야만 한다는 사실을 머리 속에 새겨놓고 있다. 늘 그런 것은 아니다. 특히, 아카이빙 작업은 더욱 그렇지 않다. 이 작업은 필요한 만큼 늘일 수 있으며, 이 작업을 완료하는 데는 더 작은 배치작업들이 도움이 된다. 이런 집약적인 작업을 더 천천히 할 수 있다면, 여분의 시간을 시스템이 다운되지 않도록 하는 데 투여하기 바란다.

11. ORM을 피하라
ORM(Object-relational Mapper: 객체 관계형 매퍼)는 지구상에서 최악의 코드를 만들어 내고 있으며, 개발자가 직면할 가능성이 있는 대부분의 성능 문제에 책임이 있다. 그렇지만, ORM을 피할 수 없다면, 스스로 자체적인 저장 프로시저를 작성하고 ORM이 자체 쿼리를 작성하는 대신 사용자가 작성한 쿼리를 호출하게 함으로써 부정적인 측면을 최소화할 수 있다.

12. 가능한 경우, 저장 프로시저(Stored Procedure)를 사용하라
더 훌륭한 코드로 이끄는 것 외에, 저장 프로시저는 다른 많은 장점도 가지고 있다. 저장 프로시저는 호출이 더 짧을 것이기 때문에, 트래픽을 크게 줄여준다. 프로파일러(Profiler) 같은 도구를 사용해서 추적하기가 더 쉬워서 사용자가 성능 통계치를 확보하고 잠재적인 문제를 더 빨리 규명할 수 있게 해준다. 더욱 일관성 있는 방식으로 정의할 수 있으며, 이는 실행 계획(Execution Plan)을 재사용할 가능성이 더 높으며, 임의 쿼리에 비해 엣지 케이스(Edge Case)와 감사용으로 사용하기가 더 쉽다는 의미이다.
많은 닷넷 코더들은 비즈니스 로직이 데이터베이스가 아닌 애플리케이션의 프론트 엔드에 속한다고 믿고 있다. 그렇지만, 그들은 틀렸다(대부분의 경우).

13. 더블 디핑(Double-Dipping: 중복 처리)을 피하라
저장 프로시저 사용은 때로 “더블 디핑”으로 이어질 수 있다. 대규모 테이블에 대해 별개의 쿼리를 여러 개 실행하고, 그것들을 임시 테이블에 넣은 다음에, 테이블들을 다시 조인하는 것이다. 이는 성능에 커다란 방해물이 될 수 있다. 가능한한 대규모 테이블을 한 번만 쿼리 하는 것이 훨씬 더 낫다.
조금 다른 시나리오는 한 프로세스의 몇 가지 단계에서 커다란 테이블의 일부가 필요한 경우로, 이는 매 번 커다란 테이블에 대한 쿼리를 유발한다. 일부에 대한 쿼리를 실행하고 그것을 다른 곳에 영속화 시킨 다음에, 후속 단계를 영속화된 더 작은 데이터 세트로 유도하라.

14. 커다란 트랜잭션은 작은 트랜잭션 여러 개로 쪼개라
단일 트랜잭션에서 여러 개의 테이블을 처리하는 작업은 해당 트랜잭션이 끝날 때까지 모든 테이블을 잠글 수 있기 때문에, 다수의 블로킹으로 이어진다. 해결책은 이 트랜잭션을 각각이 개별적으로 단일 테이블에 대한 작업을 하는 여러 개의 루틴(Routines)으로 쪼개는 것이다. 이는 블로킹 횟수를 줄여주고 다른 작업들이 계속해서 이루어질 수 있도록 다른 테이블들을 풀어준다.

15. 트리거(Trigger) 사용을 자제하라
하려고 하는 작업이 무엇이든, 원래 작업의 동일한 트랜잭션에서 수행될 것이기 때문에 트리거 사용도 비슷한 문제로 이어질 수 있다. 이는 트리거가 완료될 때까지 여러 개의 테이블을 잠그는 결과를 초래할 수 있다는 의미이다. 이런 트리거를 별개의 트랜잭션들로 쪼개면 더 적은 수의 자원을 잠그게 돼서 필요한 경우 변경사항 복원을 쉽게 만들어준다. 가능하면 트리거를 피하라.

16. GUID에 대한 클러스터링을 피하라
테이블 데이터 정렬을 위해 GUID(Globally Unique Identifier: 범용 고유 식별자)를 사용하지 말라. 임의로 생성되는 이런 16비트 숫자는 사용자의 테이블을 훨씬 더 빨리 파편화한다. DATE나 IDENTIFY 같은 값을 점진적으로 증가시켜서 데이터를 정렬하는 것이 훨씬 낫다. 휘발성 있는 모든 열에 대해서도 갖은 규칙이 적용된다. 단 몇 분 만에 극적으로 테이블들이 파편화될 수도 있다.

17. 테이블에 있는 모든 것을 카운트(Count)하지 말라
테이블에 데이터가 존재하거나 어떤 고객에 대한 데이터가 존재하는 지를 확인할 필요가 있으며, 확인 결과에 따라, 어떤 조치를 취해야 한다고 가정하자.
필자는 그런 데이터의 존재를 확인하기 위해 누군가가 SELECT COUNT(*) FROM dbo.T1 명령을 실행하는 것을 자주 보았다.\
`SET @CT = (SELECT COUNT(*) FROM dbo.T1);`\
`If @CT > 0`\
`BEGIN <Do something>`\
`END`\
전혀 불필요한 명령이다. 존재 여부를 확인하고 싶다면, 다음과 같이 하라:\
`If EXISTS (SELECT 1 FROM dbo.T1)`\
`BEGIN`\
`\<Do something\>` \
`END`\
다른 말로 하면, 테이블에 있는 모든 것을 카운트하지 말라는 것이다. 첫 번째 행으로 돌아가면 찾을 수 있다. SQL 서버는 EXIST 문을 제대로 사용할 수 있을 정도로 똑똑하며, 두 번째 블록의 코드는 아주 빠르게 결과를 돌려준다. 테이블이 크면 클수록, 더 많은 차이를 낼 것이다.

18. 행을 카운트하려면 시스템 테이블(System Table)을 사용하라
커다란 테이블의 행을 정말로 카운트할 필요가 있다면, 시스템 테이블에서 끌어 올 수 있다. ‘SELECT rows from sysindex’ 명령문은 모든 인덱스에 대한 열의 수를 알려줄 것이다.
그리고 클러스터된 인덱스가 데이터 자체를 나타내기 때문에, ‘WHERE indid = 1’을 추가하면 테이블 행을 얻을 수 있다. 그 다음에는 그냥 테이블 이름을 추가하기만 하면 만사형통이다. 이렇게 하면, 최종 쿼리는 다음과 같다
`SELECT rows FROM sysindexes WHERE object_name(id) = ‘T1’ AND indexid = 1`

19. 필요한 수의 열만 끌어오라
열을 개별적으로 나열하는 대신 모든 쿼리를 SELECT * 명령문으로만 코딩한다면 너무 쉬울 것이다. 또 다시 문제는 필요한 것보다 더 많은 데이터를 끌어 온다는 것이다. 개발자가 120개의 열과 수 백만 개의 행을 가지고 있는 테이블을 대상으로 SELECT *를 실행하고는, 겨우 3~5개만 사용하고 말았다. 그 시점에, 개발자는 필요한 것보다 훨씬 더 많은 데이터를 처리시켰을 뿐만 아니라 다른 프로세스들로부터 자원을 뺏어가기도 한 것이다.

20. 네거티브 검색(Negative Search)를 피하기 위해 쿼리를 재 작성하라
인덱스를 사용할 수 없는 쿼리를 사용해서 데이터를 행 별로 비교할 필요가 있을 때, 예를 들어 FROM Customers WHERE RegionID <> 3 같은 경우는 인덱스를 사용할 수 있도록 쿼리를 재작성하는 것이 더 낫다.\
`SELECT * FROM Customers WHERE RegionID < 3 UNION ALL SELECT * FROM Customers WHERE RegionID`\
데이터 세트가 큰 경우, 인덱스를 사용하는 것이 테이블 스캔 버전을 크게 능가하는 결과를 내 놓을 수도 있다. 물론, 더 열악한 결과를 낼 수도 있으니 구현에 앞서 시험해보라.
필자는 이 쿼리가 팁 13번(중복 처리를 피하라)을 어긴다는 것을 알았지만, 융통성 없는 규칙은 없다는 것을 보여주는 것이기도 하다. 여기서는 중복 처리를 했지만, 대가가 큰 테이블 스캔을 피하기 위해서이다.

21. 맹목적으로 코드를 재사용하지 말라
필요한 데이터를 끌어온다는 것을 알기 때문에 다른 누군가의 코드를 복사하기가 십상이다. 문제는 종종 필요한 것보다 훨씬 더 많은 데이터를 끌어오고 있으며, 개발자들이 양을 줄이려 하는 경우는 거의 없어서, 거대한 데이터 상위 집합에 이르고 만다. 이는 대개 추가적인 외부 조인(Outer Join)이나 WHERE 문에서 추가 조건 형태로 나타난다. 재사용된 코드를 꼭 필요한 수준으로 줄일 수 있다면 커다란 성능 이득을 볼 수 있다.

ref http://www.itworld.co.kr/news/105792

## 테이블 파티셔닝


